<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Furigana + 번역</title>
<link rel="icon" href="data:,">
<style>
  :root{
    --bg:#0b0f14; --card:#11161f; --ink:#e6edf3; --line:#223044; --muted:#9fb0c2; --accent:#5aa9ff;
    --anki-bg:#112019; --anki-border:#1f3b2d; --anki-ink:#cfe0f2;
    --learn-bg:#0f7d59; --learn-border:#1cc98a; --learn-ink:#ffffff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Apple SD Gothic Neo,sans-serif}
  header{padding:16px 20px;border-bottom:1px solid var(--line)}
  h1{margin:0;font-size:16px;font-weight:600}
  main{max-width:1100px;margin:0 auto;padding:20px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:14px}
  .label{font-size:13px;color:var(--muted);margin-bottom:8px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#182233;color:var(--ink);border:1px solid var(--line);padding:10px 14px;border-radius:10px;cursor:pointer}
  .btn:hover{background:#1e2a3f}
  .btn.primary{background:var(--accent);color:#06111e;border-color:#2d80e4;font-weight:600}
  .error{color:#ffb3b3}
  textarea{width:100%;min-height:120px;background:#0e141c;color:#e6edf3;border:1px solid var(--line);border-radius:10px;padding:12px;resize:vertical;line-height:1.5}

  ruby{ruby-position:over}
  ruby rt{font-size:.8em;color:#b9c8d8;opacity:1;transition:opacity .15s ease}
  #rubyOut.ruby-off ruby rt{opacity:0}

  .tok{padding:1px 2px;border-radius:6px;cursor:pointer}
  .tok:hover{background:#1a2436}
  .tok[data-clickable="0"]{cursor:default}
  .tok ruby,.tok rb,.tok rt{pointer-events:none}

  .pane{height:38vh;min-height:28vh;max-height:60vh;overflow:auto;background:#0e141c;border:1px solid var(--line);border-radius:10px;padding:12px;white-space:pre-wrap}
  @media (max-height:760px){.pane{height:34vh}}

  details summary{list-style:none;cursor:pointer;display:flex;align-items:center;gap:8px;user-select:none}
  details summary::-webkit-details-marker{display:none}
  .chev{transition:transform .2s ease}
  details[open] .chev{transform:rotate(90deg)}
  .hint{margin-left:auto;color:#9fb0c2;font-size:12px}

  #pop{
    position:fixed; z-index:9999;
    max-width:min(92vw,520px);
    max-height:80vh;
    overflow:auto; -webkit-overflow-scrolling:touch;
    background:var(--card); border:1px solid var(--line);
    border-radius:14px; padding:14px; display:none;
  }
  @supports (height: 1dvh){ #pop{ max-height:80dvh; } }
  .popTitle{font-size:22px;font-weight:800;line-height:1.2;display:inline-block;color:#e6edf3;text-decoration:none}
  .popTitle rt{font-size:.7em}
  .popSub{font-size:12px;color:#9fb0c2;margin-left:6px}
  .popTrans{font-size:15px;color:#cfe0f2;margin-top:8px;word-break:break-word}
  .popMsg{font-size:12px;color:#9fb0c2;margin-top:8px}
  .popActions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}

  .kanjiList{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .kbox{border:1px solid var(--line);border-radius:12px;padding:8px 10px}
  .kbox.anki{background:var(--anki-bg);color:var(--anki-ink);border-color:var(--anki-border)}
  .kbox.learn{background:var(--learn-bg);color:var(--learn-ink);border-color:var(--learn-border)}
  .khead{display:flex;align-items:center;gap:8px;font-size:14px;font-weight:700;background:transparent;border:0;padding:0}
  .khead.toggle{cursor:pointer}
  .khead.link{cursor:pointer;text-decoration:none;color:inherit}
  .kdesc{display:none;margin-top:6px;font-size:13px;line-height:1.5;white-space:pre-wrap;border-top:1px dashed rgba(255,255,255,.12); padding-top:6px}
  .kbox.open .kdesc{display:block}
</style>
</head>
<body>
<header><h1>Furigana + 번역</h1></header>
<main>
  <section class="card">
    <details id="inputBox">
      <summary>
        <span class="chev">▶</span><strong>입력 텍스트</strong>
        <span class="hint">클릭하여 펼치기 · Ctrl/⌘+Enter</span>
      </summary>
      <div style="margin-top:10px">
        <textarea id="input" placeholder="일본어 텍스트를 붙여넣고 ‘후리가나 & 번역’을 누르세요。"></textarea>
        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="runBtn" type="button">후리가나 & 번역</button>
        </div>
      </div>
    </details>
  </section>

  <section class="card">
    <div class="label">원문</div>
    <div id="rubyOut" class="pane" aria-live="polite"></div>
    <div class="row" style="margin-top:8px;justify-content:flex-end">
      <button class="btn" id="btnToggleRuby" type="button">루비 끄기</button>
    </div>
  </section>

  <section class="card">
    <div class="label">번역</div>
    <div id="transOut" class="pane" aria-live="polite"></div>
  </section>
</main>

<div id="pop">
  <a id="popLink" class="popTitle" href="#" target="_blank" rel="noopener"></a>
  <span id="popSub" class="popSub"></span>
  <div id="popDeepl" class="popTrans"></div>
  <div id="popKanji" class="kanjiList" style="display:none"></div>
  <div id="popMsg" class="popMsg" style="display:none"></div>
  <div class="popActions"><button class="btn" id="popClose" type="button">닫기</button></div>
</div>

<script>
/* ===== 엔드포인트 ===== */
const FURIGANA_URL = "https://furigana-api-345684237835.asia-northeast3.run.app/furigana";
const DEEPL_URL    = "https://solitary-mud-8caf.rlaalsrbr.workers.dev/translate";

/* ===== 로컬 파일 ===== */
const CROWDANKI_URL = "./일본어_한자_암기박사/deck.json?v=20251005";
const KANJI_DB_URL  = "./kanji_ko_attr_irreg.min.json?v=20251005";

/* ===== 유틸 ===== */
const $ = s=>document.querySelector(s);
function escapeHtml(s){ const d=document.createElement("div"); d.innerText=s; return d.innerHTML; }
function escapeAttr(s){ return String(s).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/</g,"&lt;"); }
function kata2hira(s){ return s.replace(/[\u30a1-\u30f6]/g, ch=>String.fromCharCode(ch.charCodeAt(0)-0x60)); }
function hasKanji(s){ return /[\u4E00-\u9FFF]/.test(s); }
function htmlToPlainWithBreaks(html){
  const tmp=document.createElement("div");
  tmp.innerHTML=String(html||"");
  return (tmp.textContent||tmp.innerText||"").replace(/\r\n/g,"\n").replace(/\n{3,}/g,"\n\n").trim();
}
function stripHtml(s){ const tmp=document.createElement("div"); tmp.innerHTML=String(s||""); return (tmp.textContent||tmp.innerText||"").trim(); }
function withTimeout(run,ms=45000,label="요청"){
  const ctrl=new AbortController(), t=setTimeout(()=>ctrl.abort(),ms);
  return Promise.race([run(ctrl.signal),(async()=>{await new Promise(r=>setTimeout(r,ms+50));throw new Error(label+" 타임아웃("+ms+"ms)");})()]).finally(()=>clearTimeout(t));
}
const SEP_WIDE=" ";

/* ===== DeepL 전처리 ===== */
const EMOJI_RE = /[\u{1F1E6}-\u{1F1FF}\u{1F300}-\u{1F5FF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu;
function compressRepeats(s){ return s.replace(/([ぁ-んァ-ン一-龯A-Za-zーｗW！？!?])\1{2,}/gu,'$1$1'); }
function preprocessTextForDeepL(s){
  if(!s) return s;
  return compressRepeats(
    s.replace(/\u200D/g,'').replace(/[\uFE0E\uFE0F]/g,'')
     .replace(/[\u{1F3FB}-\u{1F3FF}]/gu,'').replace(EMOJI_RE,'')
  );
}

/* ===== API ===== */
async function callFurigana(text){
  const body={text,perChar:false};
  const fetcher=signal=>fetch(FURIGANA_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body),signal})
    .then(r=>{if(!r.ok) throw new Error("Furigana "+r.status); return r.json();});
  return withTimeout(fetcher,45000,"Furigana");
}
async function callDeepL(text,src="JA",tgt="KO"){
  const body={text,sourceLang:src,targetLang:tgt};
  const fetcher=signal=>fetch(DEEPL_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body),signal})
    .then(r=>{if(!r.ok) throw new Error("DeepL "+r.status); return r.json();});
  return withTimeout(fetcher,45000,"DeepL");
}

/* ===== 줄 단위 번역 ===== */
function splitLineSafely(line, maxLen = 3000){
  const out=[]; if(line.length<=maxLen){out.push(line);return out;}
  const segs=line.split(/(?<=[。．\.！？!?；;：:])/); let buf="";
  for(const s of segs){
    if((buf+s).length>maxLen){ if(buf) out.push(buf),buf="";
      if(s.length>maxLen){ for(let i=0;i<s.length;i+=maxLen) out.push(s.slice(i,i+maxLen)); }
      else buf=s;
    }else buf+=s;
  }
  if(buf) out.push(buf); return out;
}
async function translateByLines(text, src="JA", tgt="KO"){
  const lines=String(text).split(/\r?\n/); const results=[];
  for(const line of lines){
    if(!line.trim()){results.push(""); continue;}
    const cleaned=preprocessTextForDeepL(line);
    const chunks=splitLineSafely(cleaned); const pieces=[];
    for(const [i,chunk] of chunks.entries()){
      try{ const r=await callDeepL(chunk,src,tgt); pieces.push(r.translation||r.result||r.data||""); }
      catch{ pieces.push(chunk); }
      if(i<chunks.length-1) await new Promise(r=>setTimeout(r,120));
    }
    results.push(pieces.join(""));
  }
  return results.join("\n");
}

/* ===== DB 로드 ===== */
let KANJI_DB=null, ANKI_DB=null;
async function loadJsonGraceful(url){
  try{ const url2=/[^\x00-\x7F]/.test(url)?encodeURI(url):url;
       const r=await fetch(url2,{cache:"force-cache"}); if(!r.ok) throw new Error("HTTP "+r.status);
       return await r.json();
  }catch(e){ console.error("JSON load failed:",url,e); return null; }
}
function buildDbFromCrowdAnki(deck){
  const modelMap=new Map(); const nms=deck.note_models||deck["note_models"]||[];
  for(const m of nms){
    const uuid=m["crowdanki_uuid"]||m["id"]||m["uuid"]||m["note_model_uuid"];
    const flds=(m.flds||m["flds"]||[]).map(o=>o&&(o.name||o["name"]||"")); if(uuid&&flds.length) modelMap.set(uuid,flds);
  }
  const db={}; const notes=[]; (function walk(x){ if(!x) return;
    if(Array.isArray(x)){x.forEach(walk); return;} if(typeof x==="object"){ if(Array.isArray(x.notes)) notes.push(...x.notes); for(const k in x) walk(x[k]); }
  })(deck);

  function splitHunEum(backText){
    const s=stripHtml(backText); if(!s) return {hun:"",eum:""};
    const parts=s.split(/\s+/);
    if(parts.length>=2){ const eum=parts[parts.length-1]; const hun=parts.slice(0,-1).join(" "); return {hun,eum}; }
    if(parts.length===1){ return {hun:"",eum:parts[0]}; }
    return {hun:"",eum:""};
  }

  for(const note of notes){
    const uuid=note["note_model_uuid"]; const names=modelMap.get(uuid)||[]; const vals=note["fields"]||note["flds"]||[];
    const iFront=names.findIndex(n=>/^front$/i.test(n));
    const iBack =names.findIndex(n=>/^back$/i.test(n));
    const iExpl =names.findIndex(n=>/^explain$/i.test(n));
    const kanji=stripHtml(iFront>=0?vals[iFront]:""); const back=iBack>=0?vals[iBack]:""; const memo=iExpl>=0?vals[iExpl]:"";
    const {hun,eum}=splitHunEum(back); const memoText=htmlToPlainWithBreaks(memo);
    if(!kanji) continue;
    for(const ch of Array.from(kanji)){
      if(!/[\u4E00-\u9FFF]/.test(ch)) continue;
      const rec=db[ch]||{"훈":"", "음":"" , "설명":""};
      function merge(oldVal,newVal){ const arr=(oldVal?oldVal.split(","):[]).map(s=>s.trim()).filter(Boolean);
        for(const t of (newVal?newVal.split(","):[])){ const s=t.trim(); if(s&&!arr.includes(s)) arr.push(s); } return arr.join(", "); }
      if(hun) rec["훈"]=merge(rec["훈"],hun);
      if(eum) rec["음"]=merge(rec["음"],eum);
      if(memoText && memoText.length>(rec["설명"]||"").length) rec["설명"]=memoText;
      db[ch]=rec;
    }
  }
  return db;
}
async function ensureDbs(){
  if(!KANJI_DB) KANJI_DB=await loadJsonGraceful(KANJI_DB_URL);
  if(ANKI_DB===null){ const deck=await loadJsonGraceful(CROWDANKI_URL); ANKI_DB=deck?buildDbFromCrowdAnki(deck):null; }
}

/* ===== 상태 ===== */
const APP=(function(){ if(!window.__APP__) window.__APP__={lastTokens:null,rubyOn:true}; return window.__APP__; })();

/* ===== 원문 렌더 ===== */
function buildRubyTokens(tokens){
  return (tokens||[]).map((t,idx)=>{
    const s=String(t.surface||""); const r=String(t.reading||""); const lemma=String(t.lemma||s);
    const rt=r?kata2hira(r):""; const inner=(hasKanji(s)&&rt)
      ? '<ruby><rb>'+escapeHtml(s)+'</rb><rt>'+escapeHtml(rt)+'</rt></ruby>' : escapeHtml(s);
    const clickable=s.trim()?"1":"0";
    return '<span class="tok" data-i="'+idx+'" data-clickable="'+clickable+'"'
      +' data-surface="'+escapeAttr(s)+'" data-lemma="'+escapeAttr(lemma)+'" data-reading="'+escapeAttr(rt)+'">'+inner+'</span>';
  }).join("");
}
function renderText(){ if(!APP.lastTokens) return;
  $("#rubyOut").innerHTML=buildRubyTokens(APP.lastTokens);
  $("#rubyOut").classList.toggle("ruby-off",!APP.rubyOn);
  $("#btnToggleRuby").textContent = APP.rubyOn ? "루비 끄기" : "루비 켜기";
}

/* ===== lemma 읽기 캐시 ===== */
const lemmaReadCache=new Map();
function readingFromTokens(tokens){ return (tokens||[]).map(t=>{const r=String(t.reading||""); const s=String(t.surface||""); return r?kata2hira(r):s;}).join(""); }
function getLemmaReading(lemma){
  if(!lemma) return Promise.resolve(""); if(lemmaReadCache.has(lemma)) return Promise.resolve(lemmaReadCache.get(lemma));
  return callFurigana(lemma).then(res=>{ const rt=readingFromTokens(res.tokens||[]); lemmaReadCache.set(lemma,rt); return rt; })
    .catch(()=>{ lemmaReadCache.set(lemma,""); return ""; });
}

/* ===== 팝업 위치 ===== */
function positionPopupToToken(tokEl){
  const pad=8; pop.style.visibility="hidden"; pop.style.display="block";
  const prect=tokEl.getBoundingClientRect(); const rect=pop.getBoundingClientRect();
  const vw=window.innerWidth, vh=window.innerHeight;
  let left=prect.left, top=prect.bottom+6;
  if(left+rect.width+pad>vw) left=Math.max(vw-rect.width-pad,pad);
  if(left<pad) left=pad;
  if(top+rect.height+pad>vh){ const tryTop=prect.top-rect.height-6; top=(tryTop>=pad)?tryTop:Math.max(vh-rect.height-pad,pad); }
  if(vw<360){ left=Math.max((vw-rect.width)/2,pad); }
  pop.style.left=`${left}px`; pop.style.top=`${top}px`; pop.style.visibility="visible";
}

/* ===== 네이버 링크 ===== */
function buildNaverSearchUrl(q){ return "https://ja.dict.naver.com/#/search?query="+encodeURIComponent(q||""); }

/* ===== 한자 박스 ===== */
const pop=$("#pop"), popLink=$("#popLink"), popSub=$("#popSub"), popDeepl=$("#popDeepl");
const popKanji=$("#popKanji"), popMsg=$("#popMsg");
function makeKanjiBox({ch, kr, cls, descText="", dictHref=""}){
  const box=document.createElement("div"); box.className=`kbox ${cls}`;
  let head;
  if(cls==="learn" && dictHref){ head=document.createElement("a"); head.className="khead link"; head.href=dictHref; head.target="_blank"; head.rel="noopener"; }
  else{ head=document.createElement("div"); head.className="khead toggle"; }
  head.textContent=`${ch} · ${kr||""}`; box.appendChild(head);
  if(cls==="anki" && descText){ const d=document.createElement("div"); d.className="kdesc"; d.textContent=htmlToPlainWithBreaks(descText); box.appendChild(d); head.addEventListener("click",()=>box.classList.toggle("open")); }
  return box;
}
async function fillKanjiBoxes(lemma){
  popKanji.style.display="none"; popKanji.innerHTML=""; popMsg.style.display="none"; popMsg.textContent="";
  await ensureDbs(); const dbA=ANKI_DB, dbK=KANJI_DB;
  const uniq=[]; for(const ch of Array.from(lemma)){ if(/[\u4E00-\u9FFF]/.test(ch) && !uniq.includes(ch)) uniq.push(ch); }
  let created=0;
  for(const ch of uniq){
    const aRec=dbA&&dbA[ch]; const kRec=dbK&&dbK[ch];
    if(aRec){ const hun=aRec["훈"]||"", eum=aRec["음"]||""; let kr=""; if(hun) kr+=hun; if(hun&&eum) kr+=SEP_WIDE; if(eum) kr+=eum;
      popKanji.appendChild(makeKanjiBox({ch, kr, cls:"anki", descText:aRec["설명"]||""})); created++; continue; }
    const hun=(kRec&&kRec["훈"])||"", eum=(kRec&&kRec["음"])||""; let kr=""; if(hun) kr+=hun; if(hun&&eum) kr+=SEP_WIDE; if(eum) kr+=eum;
    const href="https://hanja.dict.naver.com/#/search?query="+encodeURIComponent(ch);
    popKanji.appendChild(makeKanjiBox({ch, kr, cls:"learn", dictHref:href})); created++;
  }
  if(created>0) popKanji.style.display="flex";
  const hasAnyKanji=uniq.length>0;
  if(!created && hasAnyKanji){ popMsg.textContent = KANJI_DB ? "일치하는 한자 항목이 없습니다." : "로컬 사전을 불러오지 못했습니다."; popMsg.style.display="block"; }
}

/* ===== 문장 문맥 ===== */
function sentenceAround(tokens, idx, maxLen=400){
  if(!tokens||idx<0||idx>=tokens.length) return "";
  const isEnd=s=>/[。．\.！？!?]/.test(String(s||"")); let L=idx,R=idx;
  while(L>0 && !isEnd(tokens[L-1].surface)) L--;
  while(R<tokens.length-1 && !isEnd(tokens[R].surface)) R++;
  let sent=tokens.slice(L,R+1).map(t=>String(t.surface||"")).join("").replace(/\s+/g,"");
  if(sent.length>maxLen) sent=sent.slice(0,maxLen);
  return sent;
}

/* ===== 센티넬 파서 ===== */
function pickBetweenSentinel(s, start="[[[", end="]]]") {
  const t = String(s ?? "");
  const i = t.indexOf(start);
  if (i < 0) return "";
  const j = t.indexOf(end, i + start.length);
  if (j < 0) return "";
  return t.slice(i + start.length, j).trim();
}

/* ===== 팝업 ===== */
function openPopBelowToken(tokEl, payload){
  const surface=payload.surface||"", lemma=payload.lemma||surface;

  popLink.innerHTML=escapeHtml(lemma);
  popLink.href=buildNaverSearchUrl(lemma);
  popSub.textContent=(surface&&surface!==lemma)?"("+surface+")":"";

  if(hasKanji(lemma)){
    getLemmaReading(lemma).then(rt=>{
      popLink.innerHTML = rt ? `<ruby><rb>${escapeHtml(lemma)}</rb><rt>${escapeHtml(rt)}</rt></ruby>` : escapeHtml(lemma);
    });
  }

  popDeepl.textContent="불러오는 중…";

  const tIdx = Number(tokEl.dataset.i || -1);
  const sent = sentenceAround(APP.lastTokens || [], tIdx);

  // 반드시 [[[ … ]]] 사이에만 답을 넣도록 지시
  const prompt =
`文脈：『${sent}』。
語「${lemma}」の韓国語訳を1語だけ、名詞の基本形で出力してください。
出力は必ず [[[ 단어 ]]] の形にし、それ以外の文は書かないでください。`;

  callDeepL(preprocessTextForDeepL(prompt), "JA", "KO")
    .then(async res=>{
      let raw = res.translation || res.result || res.data || "";
      let picked = pickBetweenSentinel(raw);

      // 없으면 lemma 단독 재시도(동일 규칙)
      if(!picked){
        try{
          const r2 = await callDeepL(
            preprocessTextForDeepL(
              `語「${lemma}」の韓国語訳を1語だけ、名詞の基本形で出力してください。出力は必ず [[[ 단어 ]]] の形に。`
            ),
            "JA","KO"
          );
          raw = r2.translation || r2.result || r2.data || "";
          picked = pickBetweenSentinel(raw);
        }catch{}
      }
      popDeepl.textContent = picked || "(결과 없음)";
    })
    .catch(e=>{
      popDeepl.textContent = "에러: " + (e?.message ?? String(e));
    });

  fillKanjiBoxes(lemma);
  positionPopupToToken(tokEl);
}
function closePop(){ pop.style.display="none"; }

/* ===== 실행 ===== */
async function runBoth(){
  const text=$("#input").value.trim();
  if(!text){ const box=$("#inputBox"); if(!box.open) box.open=true; $("#input").focus(); return; }
  $("#rubyOut").innerHTML="<em style='color:#9fb0c2'>생성 중…</em>";
  $("#transOut").innerHTML="<em style='color:#9fb0c2'>번역 중…</em>";
  try{
    const [furi, tstr] = await Promise.all([ callFurigana(text), translateByLines(text,"JA","KO") ]);
    APP.lastTokens=furi.tokens||[]; renderText();
    $("#transOut").innerHTML = tstr ? escapeHtml(tstr).replace(/\n/g,"<br>") : "<em style='color:#9fb0c2'>결과 없음</em>";
  }catch(e){
    $("#rubyOut").innerHTML='<span class="error">에러(후리가나): '+escapeHtml(e?.message||String(e))+'</span>';
    $("#transOut").innerHTML="";
  }
}

/* ===== 바인딩 ===== */
(function bindOnce(){
  if(window.__BOUND__) return; window.__BOUND__=true;
  $("#runBtn").addEventListener("click",runBoth);
  $("#btnToggleRuby").addEventListener("click",()=>{
    APP.rubyOn=!APP.rubyOn;
    $("#rubyOut").classList.toggle("ruby-off",!APP.rubyOn);
    $("#btnToggleRuby").textContent = APP.rubyOn ? "루비 끄기" : "루비 켜기";
  });
  $("#rubyOut").addEventListener("click",(e)=>{
    let el=(e.target instanceof Element)?e.target:null;
    while(el && !el.classList.contains("tok")) el=el.parentElement;
    if(!el || el.dataset.clickable==="0") return;
    openPopBelowToken(el,{surface:el.dataset.surface||"", lemma:el.dataset.lemma||""});
  });
  document.addEventListener("click",(e)=>{
    if(pop.style.display==="block"){
      if(!pop.contains(e.target) && !e.target.closest(".tok")) closePop();
    }
  });
  $("#popClose").addEventListener("click",closePop);
  window.addEventListener("keydown",(e)=>{ if((e.ctrlKey||e.metaKey)&&e.key==="Enter"){ e.preventDefault(); runBoth(); } });
  $("#inputBox").addEventListener("toggle",()=>{ if($("#inputBox").open) $("#input").focus(); });
})();

/* ===== 단축어 연동 ===== */
function getQueryText(){
  const sp=new URLSearchParams(location.search);
  let q=sp.get("text"); if(!q) return "";
  try{q=decodeURIComponent(q);}catch(_){}
  try{q=decodeURIComponent(q);}catch(_){}
  return q;
}
(function initFromQuery(){
  const qText=getQueryText();
  if(qText){ $("#input").value=qText; if(new URLSearchParams(location.search).get("auto")==="1"){ runBoth(); } }
})();
</script>
</body>
</html>
